# Реализация приоритетной очереди на основе d-кучи, упорядоченной таблицы и бинарного поискового дерева и её применение для построения остовного дерева с помощью алгоритма Краскала
## Содержание
* [Постановка задачи](#Постановка-задачи)
* [Руководство пользователя](#Руководство-пользователя)
  * [Использование реализации пирамидальной сортировки](#Использование-реализации-пирамидальной-сортировки)
  * [Использование реализации алгоритма Дейкстры](#Использование-реализации-алгоритма-Дейкстры)
  * [Использование реализации алгоритма Краскала](#Использование-реализации-алгоритма-Краскала)
* [Руководство программиста](#Руководство-программиста)
  * [Используемые технологии](#Используемые-технологии)
  * [Общая структура репозитория](#Общая-структура-репозитория)
  * [Описание структуры решения](#Описание-структуры-решения)
  * [Описание структур данных](#Описание-структур-данных)
	  * [D-куча](#d-куча)
	  * [Бинарное поисковое дерево](#Бинарное-поисковое-дерево)
	  * [Таблицы](#Таблицы)
	    * [Просматриваемые таблицы](#Просматриваемые-таблицы)
	    * [Упорядоченные таблицы](#Упорядоченные-таблицы)
    * [Приоритетные очереди](#Приоритетные-очереди)
    * [Разделенные множества](#Разделенные-множества)
  * [Описание алгоритмов](#Описание-алгоритмов)
		* [Пирамидальная сортировка](#Пирамидальная-сортировка)
		* [Алгоритм Дейкстры](#Алгоритм-Дейкстры)
		* [Алгоритм Краскала](#Алгоритм-Краскала)
  * [Программная реализация структур данных](#Программная-реализация-структур-данных)
		* [Программная реализация d-кучи](#Программная-реализация-d-кучи)
		* [Программная реализация бинарного поискового дерева](#Программная-реализация-бинарного-поискового-дерева)
		* [Программная реализация просматриваемых таблиц](#Программная-реализация-просматриваемых-таблиц)
		* [Программная реализация упорядоченных таблиц](#Программная-реализация-упорядоченных-таблиц)
		* [Программная реализация приоритетной очереди на основе d-кучи](#Программная-реализация-приоритетной-очереди-на-основе-d-кучи)
		* [Программная реализация приоритетной очереди на основе бинарного поискового дерева](#Программная-реализация-приоритетной-очереди-на-основе-бинарного-поискового-дерева)
		* [Программная реализация приоритетной очереди на основе упорядоченной таблицы](#Программная-реализация-приоритетной-очереди-на-основе-упорядоченной-таблицы)
		* [Программная реализация разделенных множеств](#Программная-реализация-разделенных-множеств)
		* [Программная реализация графа](#Программная-реализация-графа)
* [Заключение](#Заключение)
* [Литература](#Литература)

## Постановка задачи

1. Разработать статические библиотеки, реализующие следующие структуры данных:
	- d-кучу;
	- бинарное поисковое дерево;
	- граф;
	- разделенные множества;
	- таблицу;
	- просматриваемую таблицу;
	- упорядоченную таблицу;
	- приоритетную очередь, основанную на d-куче;
	- приоритетную очередь, основанную на бинарном поисковом дереве;
	- приоритетную очередь, основанную на упорядоченной таблице.
2. Написать тестирующую программу для каждого метода каждой структуры данных с помощью Google C++ Testing Framework.
3. Написать приложение для демонстрации работы d-кучи (пирамидальная сортировка).
4. Написать приложение для демонстрации работы приоритетной очереди, основанной на d-куче (алгоритм Дейкстры):
	- входные данные - связный неориентированный взвешенный граф без петель;
	- выходные данные:
	    - список кратчайших путей до каждой вершины графа;
	    - список предшествующий вершин.
5. Написать приложение для демонстрации работы приоритетных очередей (на базе D-кучи, бинарного поискового дерева и упорядоченной таблицы) и разделенных множеств (алгоритм Краскала):
	- входные данные - связный неориентированный взвешенный граф без петель;
	- выходные данные - граф, представляющий минимальное остовное дерево для исходного графа.

## Руководство пользователя

###Использование реализации пирамидальной сортировки

####Запуск приложения и ввод данных

Программа предназначена для сортировки d-кучи.
Для запуска приложения нужно открыть исполняемый файл `sample_sort.exe`.
Программа запросит арность кучи и количество элементов. Программа сгенерирует кучу, с учетом ваших данных. На экран выведется сначала исходная куча, затем отсортированная.

####Пример:

1) После запуска программы необходимо ввести арность кучи:

![1](/img/sort1.png)

2) Затем необходимо ввести количество элементов в куче:

![2](/img/sort2.png)

3) После этого программа выведет исходную и отсортированную кучу:

![3](/img/sort3.png)

###Использование реализации алгоритма Дейкстры

####Запуск приложения и ввод данных

Программа предназначена для поиска кратчийших путей во взвешенном неориентированном графе от стартовой вершины до всех остальных вершин графа.
Для запуска приложения нужно открыть исполняемый файл `sample_Dijkstra.exe`.
Программа предлагает пользовательский ввод или пример, предлагаемый программой.
Программа попросит ввести количество вершин графа, значения весов ребер. Cтартовая вершина по умолчанию нулевая. Результатом будет вывод кратчайших путей от стартовой вершины и номеров предшествующих вершин.

####Пример:

1)Продемонстрируем пользовательский ввод:

![4](/img/d1.png)

2) Необходимо ввести количество вершин графа:

![5](/img/d2.png)

3) Введите значения весов рёбер графа, соединяющих вершины i и j:

![6](/img/d3.png)

4) Получим результат:

![7](/img/d4.png)

###Использование реализации алгоритма Краскала

####Запуск приложения и ввод данных

Программа предназначена для построения минимального остовного дерева для взвешенного неориентированного графа. 
Для запуска приложения нужно открыть исполняемый файл `sample_Kruskal.exe`.
Программа попросит выбрать структуру данных, на которой будет основоваться приоритетная очередь, и количество вершин графа.
Программа предлагает пользовательский ввод или пример, предлагаемый программой.
Результатом работы программы будет вывод списка ребер, составляющих минимальное остовное дерево, и их весов.

####Пример

1) Выбираем структуру данных для приоритетной очереди:

![8](/img/k1.png)

2) Продемонстрируем пользовательский ввод:

![9](/img/k2.png)

2) Вводим число вершин графа:

![10](/img/k3.png)

3) Вводим данные:

![11](/img/k4.png)

4) Программа завершила работу и вывела результат на экран:

![12](/img/k5.png)

##Руководство программиста

###Используемые технологии

В ходе выполнения работы использованы следующее ПО:
- Среда разработки Microsoft Visual Studio 2012.
- Фреймворк для написания автоматических тестов Google Test.
- Система контроля версий Git.

###Общая структура репозитория

Репозиторий содержит следующие директории и файлы:

* [`gtest`](https://github.com/sinitskaya/lab4_Kr/tree/q1/gtest) - библиотека GoogleTest.
* [`include`](https://github.com/sinitskaya/lab4_Kr/tree/q1/include) - директория для размещения заголовочных файлов и реализаций структур данных.
* [`samples`](https://github.com/sinitskaya/lab4_Kr/tree/q1/samples) - директория для размещения исходного кода приложения алгоритма Дейкстры, Краскала, пирамидальной сортировки.
* [`tests`](https://github.com/sinitskaya/lab4_Kr/tree/q1/test) - директория для размещения тестов.
* [`sln`](https://github.com/sinitskaya/lab4_Kr/tree/q1/sln/vc12) - директория с файлими решений (на данный момент Visual Studio 2012).
* [`img`](https://github.com/sinitskaya/lab4_Kr/tree/q1/img) - директория с изображениями для отчета;
* [`src`](https://github.com/sinitskaya/lab4_Kr/tree/q1/src) - директория для размещения реализационных файлов

###Описание структуры решения

Решение состоит из 12 проектов:

* `bin_TREE_lib` - статическая библиотка, содержащая объявление и реализацию шаблонного класса `BSearchTree`.
* `d_heap_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса `D_heap`.
* `table` - статическая библиотека, содержащая объявление и реализацию шаблонных классов `TabRecord`, `Table`, `ScanTable`, `SortTable`.
* `graph_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного классов `Graph`.
* `disjoint_set_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса разделенных множестве `Disjoint_set`.
* `queue_lib` - статическая библиотека, содержащая объявление и реализацию абстрактного шаблонного класса приоритетной очереди и шаблонных классов-наследников приоритетных очередей, основанных на d-куче, бинарном поисковом дереве и упорядоченной таблице `Queue`, `D_heap_Queue`, `BSearchTree_Queue`, `SortTable_Queue`.
* `algorithm` - статическая библиотека, содержащая объявление и реализацию шаблонного класса `Algorithm`, содержащего алгоритм Крускала и Дейкстры.
* `sample_Dijkstra` - консольное приложение для демонстрации работы алгоритма Дейкстры.
* `sample_Kruskal` - консольное приложение для демонстрации работы алгоритма Краскала.
* `sample_sort` - консольное приложение для демонстрации работы пирамидальной сортировки.
* `gtest` - фреймворк Google Test.
* `test` - консольное приложение для проверки правильности реализации классов `BSearchTree`, `D_heap`, `D_heap_Queue`, `BSearchTree_Queue`, `SortTable_Queue`, `Disjoint_set`, `Scan_table`, `Sort_table`.


###Описание структур данных

####D-куча

D-куча - завершенное d-арное дерево, содержащее набор однотипных элементов, со следующими свойствами:
- каждый узел, не являющийся листом, за исключением, быть может, одного имеет ровно d потомков. Один узел, являющийся исключением, может иметь от 1 до d-1 потомка;
- если h - глубина дерева, то для любого i = 1, ..., k-1 такое дерево имеет ровно d^i узлов глубины i;
- количество узлов глубины k в дереве глубины k может варьироваться от 1 до d^k;
- каждый узел имеет вес. Иначе говоря, каждому узлу дерева присвоен ключ такого типа данных, на котором определен порядок сравнения;
- ключ элемента, приписанного узлу i, не превосходит ключа любого из своих потомков.

######Основные операции
* Транспонирование `Swap` (трудоемкость = O(1))
```
ТРАНСПОНИРОВАНИЕ(i, j)
{
	tmp = key[i];
	key[i] = key[j];
	key[j] = tmp;
}
```
* Всплытие `SiftUp` (трудоемкость = log(n)):
```
ВСПЛЫТИЕ(i)
{
	p = (i - 1) / d;
	while (i != 0 && key[p] > key[i])
	{	
		ТРАНСПОНИРОВАНИЕ(i, p);
		i = p;
		p = (i - 1) / d;
	}
}
```
* Погружение `SiftDown` (трудоемкость = О(d*log(n)):
```
ПОГРУЖЕНИЕ(i)
{
	с = minchild(i); 
	while (i != 0 && key[c] < key[i])
	{
		ТРАНСПОНИРОВАНИЕ(i, c);
		i = c;
		c = minchild(i);
	}
}
```
* Вставка элемента `Push` (трудоемкость = О(log(n)):
```
ВСТАВКА(x)
{
	key[size] = x;
	ВСПЛЫТИЕ(size);
	size++;
}
```
* Удаление элемента c минимальным ключом `RemoveMin` (трудоемкость = О(log(n)):
```
УДАЛЕНИЕ_С_МИНИМАЛЬНЫМ_КЛЮЧОМ()
{
	key[0] = key[size - 1];
	size--;
	ПОГРУЖЕНИЕ(0);
}
```
* Удаление элемента с заданным ключом `Remove` (трудоемкость = О(log(n)):
```
УДАЛЕНИЕ(i)
{
	key[i] = key[size - 1];
	size--;
	ПОГРУЖЕНИЕ(i);
}
```
* Окучивание `Heapify` (трудоемкость = О(log(n)):
```
ОКУЧИВАНИЕ()
{
	for(int i = size - 1; i >= 0; i--)
	ПОГРУЖЕНИЕ(i);
}
```
* Индекс минимального ребенка `MinChild` (трудоемкость = O(1)):
```
MINCHILD(i)
{
	minc = i*d+1;
	if( minc < n-1 )
		t = i*d + 1;
	else
		t = n-1;
	for (int k=minc; k<=t; k++)
		if(keys[k] < keys[minc])
			minc = k;
}
```

####Бинарное дерево

#####Бинарное поисковое дерево
Бинарное поисковое дерево - это двоичное дерево, обладающее следующими свойствами:
* каждый узел имеет не больше двух потомков;
* любое поддерево является бинарным поисковым деревом;
* значение ключа любого узла левого поддерева меньше значения ключа корневого узла;
* значение ключа любого узла правого поддерева больше значения ключа корневого узла.

######Основные операции
* Вставка элемента `Insert` (трудоемкость = log(n)):
```
ВСТАВКА(Node)
{
	x = root;
	while(x != 0)
	{
		y = x;
		if (node->key >= x->key) 
			x = x->right;
		else 
			x = x->left;
	}
	if (node->key >= y->key) 
		y->right = node;
	else 
		y->left = node;
	node->parent = y;
}
```
* Удаление элемента `Delete`:
```
УДАЛЕНИЕ(key)
{
	x = FindKey(root_, key);
	
	//list
	if((x->left == 0) && (x->right == 0))
	{
		if(x->parent!=0)
		{
			if(x->parent->right == x)
				x->parent->right = 0;
			else
				x->parent->left = 0;
			delete x;
			return;
		}
	}

	//1 потомок
	if((x->left==0) && (x->right!=0))
	{
		if(x->parent!=0) 
		{
			y = x->right;
			y->parent = x->parent;

			if(x->parent->right==x)
				x->parent->right = y;
			else
				x->parent->left = y;
			delete x;
			return;
		}
	}
	if((x->left!=0) && (x->right==0))
	{
		if(x->parent!=0)
		{
			y = x->left;
			y->parent = x->parent;
			if(x->parent->left==x)
				x->parent->left = y;
			else
				x->parent->right = y;
			delete x;
			return;
		}
	}

	//2 потомка
	y = FindMin(x->right);
	x->e.key = y->e.key;
	y->parent->left = y->right;
	
	if(y->right!=0)
		y->right->parent = y->parent;
	delete y;
}
```
* Поиск элемента `FindKey` (трудоемкость = n):
```
ПОИСК(key)
{
	while ((root_) && (root_->e.key != key1))
		if (key1 < root_->e.key)
			root_ = root_->left;
		else
			root_ = root_->right;
	return root_;
}
```
* Обход в прямом порядке `WorkAroundForward`:
```
ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(Node *tree)
{
	cout << key;
	ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(tree->left);
	ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(tree->right);
}
```
* Обход в обратном порядке `WorkAroundReverse`:
```
ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(Node *tree)
{
	ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(tree->left);
	ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(tree->right);
	cout << key;
}
```
* Симметричный обход `WorkAroundSymmetric`:
```
СИММЕТРИЧНЫЙ_ОБХОД(Node *tree)
{
    	СИММЕТРИЧНЫЙ_ОБХОД(tree->left);
	cout << key;
	СИММЕТРИЧНЫЙ_ОБХОД(tree->right);
}
```
* Обход в ширину `WorkAroundWidth`:
```
ОБХОД_В_ШИРИНУ()
{
	queue <Node*> q;
	q.ВСТАВКА(tree);	
	while (!q.empty())
	{
		Node *tmp = q.top();
		cout << key;
		q.pop();		
		if (tmp->left != 0)
			q.ВСТАВКА (tmp->left);
		if (tmp->right != 0)
			q.ВСТАВКА (tmp->right);		
	}
}
```
* Обход в глубину `WorkAroundDepth`:
```
ОБХОД_В_ГЛУБИНУ
{
	stack<Node*> s;
	s.push(tree);
	while (!s.empty() )
	{
		Node* tmp = s.top();
		cout << key;
		s.pop();
		if (tmp->right != 0)
			s.ВСТАВКА(tmp->right);
		if (tmp->left != 0)
			s.ВСТАВКА(tmp->left);
	}
}
```

####Таблицы

#####Просматриваемые таблицы
Таблица - динамическая структура данных, хранящая однотипные элементы. Записи хранятся в векторе памяти в порядке добавления (добавление производится в конец таблицы). При удалении записи просиходит перепаковка (сдвиг всех записей ниже текущей на одну позицию вверх).

######Основные операции
Полсматриваемые таблицы.
* Вставка `Insert`:
```
ВСТАВИТЬ(record)
{
	recs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ] = record;
	ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ++;
}
```
* Удаление `Delete`:
```
УДАЛЕНИЕ(key)
{
	if(Search(key1) == 0)
		return;	
	delete recs[pos];
	recs[pos] = recs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ-1];
	ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ--;
}
```
* Поиск `Search`:
```
НАЙТИ(key)
{
	for (int i=0; i<ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; i++)
		if(key1 == recs[i]->GetKey())
		{
			pos = i;
			return recs[i];
		}
	return 0;
}
```

#####Упорядоченные таблицы
Упорядоченная таблица - это просматриваемая таблица, данные в которой отсортированы по невозрастанию/неубыванию ключей. Причем при вставке и удалении происходят перепаковки.

######Основная операция
* Сортировка элементов `Sort` (трудоемкость = log(n)):
```
СОРТИРОВКА()
{
	for(int i=0; i<ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; i++)
		for(int j=i+1; j<ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; j++)
			if(recs[i]->key > recs[j]->key)
			{
				TabRecord* tmp = recs[i];
				recs[i] = recs[j];
				recs[j] = tmp;
			}
}
```

####Приоритетные очереди
Приоритетная очередь — это динамическая структура данных, содержащая элементы, каждый из которых имеет определенный приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. Если у элементов одинаковые приоритеты, они располагаются в зависимости от своей позиции в очереди. 

######Основные операции:
* Вставка элемента `Push`.
* Удаление элемента с максимальным приоритетом `Pop`.
* Получение элемента с максимальным приоритетом `Top`.
* Проверка очереди на пустоту `IsEmpty`.
* Проверка очереди на полносту `IsFull`.

####Разделенные множества
Разледенные множества - абстрактный тип данных, предназначенный для представления коллекции из некоторого числа k попарно непересекающихся подможеств заданного множества.

######Основные операции
* Создание синглтона `CreateSingleton` (трудоемкость = О(1)):
```
СОЗДАНИЕ_СИНГЛТОНА(x)
{
	parent[x] = x;
	height[x] = 0;
}
```
* Объединение множеств `Union` (трудоемкость = О(n)):
```
ОБЪЕДИНЕНИЕ_МНОЖЕСТВ(x,y)
{
	if (height[x] > height[y])
		parent[y] = x;
	else 
		if (height[x] < height[y])
			parent[x] = y;
		else
		{
			parent[y] = x;
			height[x]++;
		}
}
```
* Поиск подмножества `FindSubset` (трудоемкость = О(1)):
```
ПОИСК_ПОДМНОЖЕСТВА(x)
{
	int i = x, c = -1;
	if (p[x]!=x)
		while (i!=p[i])
		{
			c = p[i];
			i = p[c];
		}
	return i;
}
```

###Описание алгоритмов

####Пирамидальная сортировка
1. На вход поступает 2 значения: арность кучи и количество элементов.
2. Формируется куча.
3. Минимальный элемент d-кучи меняется с последним.
4. Размер d-кучи уменьшаем на 1.
5. Погружаем нулевой элемент.
6. 3-5 повторяется size-1 раз.

Таким образом, значения будут отсортированы по возрастанию.

####Алгоритм Дейкстры

1. На вход поступает количество вершин, значения веса ребер, соединяющих вершины i и j.
2. Формируется граф `graph`.
3. Создается массив `up`, содержащий вершины, предшествующие вершине i при обходе по дереву. Всем элементам присваивается -1.
4. Создается массив `dist` (всем элементам присваевается бесконечная метка `MAX`, `dist[0] = 0`). dist[i] - кратчайшее растояние от 0 до вершины i.
5. Первая вершина объявляется текущей.
6. Вес всех невыделенных вершин пересчитывается по формуле: вес невыделенной вершины есть минимальное число из старого веса данной (невыделенной) вершины, суммы веса текущей вершины и веса ребра, соединяющего текущую вершину с невыделенной.
7. Текущей вершиной становится следующая. Пункт 6 повторяется для всех вершин.
6. На выходе получим 2 массива: 
    - Массив `dist` содержит кратчайшие расстояния до каждой вершины графа `graph`.
    - Массив `up` содержит предшествующие вершины.

####Алгоритм Краскала

1. Алгоритму на вход поступает граф и абстрактная очередь.
3. Создается приоритетная очередь из списка ребер.
4. Создается разделенное множество из всех вершин.
5. Вынимается ребро из приоритетной очереди.
6. Если вершины, вынутые из очереди не принадлежат одному множеству, то 2 множества объдиняются, а данное ребро добавляется в результирующий список ребер.
7. 5-6 повторяются, пока очередь не станет пустой.

На выходе получаем набор ребер и их весов, составляющих минимальное остовное дерево для данного графа.

###Программная реализация структур данных

####Программная реализация d-кучи
D-куча представлена классом `D_heap`, содержащим следующие поля:
- `int d` - арность дерева.
- `KeyT *keys` - массив ключей.
- `int size` - количество элементов.

Класс содержит следующие методы:

- `GetD()` - получить d.
- `SetD(int d1)` - установить d.
- `Swap(int i, int j)` - транспонирование.
- `siftUp(int i)` - всплытие.
- `siftDown(int i)` - погружение.
- `DeleteMinKey()` - удаление с мин ключом.
- `DeleteIndex(int i)` - удаление с заданным индексом.
- `Heapify()` - окучивание.
- `MinChild(int i)`-индекс минимального потомка.
- `InsertKey(KeyT key)` - вставка нового ключа.
- `Hight()` - кол-во слоев(высота).
- `IsEmpty()` - проверка на пустоту.
- `Print()` - вывод кучи с высотой.
- `PrintMas()` - другой вывод кучи.
- `operator ==(const D_heap<KeyT> &heap)const` - проверка на равенство.
- `operator !=(const D_heap<KeyT> &heap)const` - проверка на неравенство.
- `operator =(const D_heap<KeyT> &heap)` - перегрузка оператора `=`.

####Программная реализация бинарного поискового дерева
Узел дерева представляется классом `Node`, содержащим следующие поля:
* `Edge<KeyT> e` - ребро и вес ребра.
* `Node<KeyT>* left` - указатель на левого потомка.
* `Node<KeyT>* right` - указатель на правого потомка.
* `Node<KeyT>* parent` - указатель на родителя.
* `int hight` - баланс поддерева.

Бинарное поисковое дерево представлено классом `BSearchTree`, содержащим следующие поля:
* `Node<KeyType> *root` - указатель на корень дерева.

Класс содержит следующие методы:
- `FindKey(Node<KeyT> *root_, KeyT key1)` - поиск с заданным ключом
- `FindMin(Node<KeyT> * node)` - поиск минимального элемента
- `FindMax(Node<KeyT> * node)` - поиск максимального элемента
- `FindNext(Node<KeyT>* node)` - поиск следущего за заданным
- `FindPred(Node<KeyT>* node)` - поиск предыдущего за заданным
- `GetNodeKey(Node<KeyT>* node)` - получить значение ключа
- `Insert(Node<KeyT>* node)` - вставка
- `Delete(Node<KeyT>* root_, KeyT key1)` - удаление
- `DeleteRoot()` - удаление корня
- `Print(Node<KeyT> *root_)` - печать //обход в глубину в прямом порядке
- `Print1(Node<KeyT> *root_)` - другая печать

####Программная реализация просматриваемых таблиц
Запись в таблице представлена классом `TabRecord`, содержащим следующие поля:
* `VT key` - ключ.
* `Node<KeyT>* data` - данные.

База для всех таблиц представлена классом `Table`, имеющим следующие поля:
* `int size` - размер таблицы.
* `int count` - количество записей в таблице.
* `int pos` - текущая позиция.

Класс содержит методы:
* `Search(VT key1)` - поиск элемента по идентификатору.
* `Insert(VT, Node<KeyT>*)` - вставка записи.
* `Delete(VT)` - удаление записи.
* `GetCount()` - получение текущего количества записей.
* `Reset()` - переход на начало таблицы.
* `GoNext()` - переход к следующей записи.
* `GetSize()` - получить размер таблицы.
* * `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `IsTabEnded ()` - конец ли таблицы.

Просматриваемые таблицы представлены классом `Scan_table`, содержащим поле:
* `TabRecord<KeyT>** recs` - записи в таблице.

Класс содержит следующие методы:
* `Search(VT)` - поиск записи.
* `Insert(VT, KeyT)` - вставка записи.
* `Delete(VT)` - удаление записи.
* `print()` - вывод на экран.

####Программная реализация упорядоченных таблиц
Упорядоченные таблицы наследуются от класса `Scan_table` и представлены классом `Sort_table`, содержащим следующие методы:
* `SortData()` - сортировка данных по ключам.
* `Search(VT)` - поиск записи.
* `Insert(VT, KeyT)` - вставка записи.
* `Delete(VT)` - удаление записи.
* `GetMin()` - возвращает минимальную по ключу запись.

####Программная реализация приоритетной очереди на основе d-кучи
Приоритетная очередь на основе d-кучи представлена классом `D_heap_Queue`, содержащим поле:
* `D_heap<KeyT> *heap` - указатель на кучу.

Класс содержит следующие методы:
- `SetQsize(int s)` - установить размер очереди.
- `GetQsize(void)` - получить размер.
- `Pop()` - изьятие из начала(с мин меткой).
- `Top()` - изьятие ребра без удаления.
- `Insert(Node<KeyT>* n, int i)` - вставка элемента.
- `IsEmpty()` - проверка на пустоту.
- `operator =(const D_heap_Queue<KeyT>& q)` - оператор `=`.
- `operator ==(const D_heap_Queue<KeyT> &q)const` - проверка на равенство.
- `operator !=(const D_heap_Queue<KeyT> &q)const` - проверка на неравенство.
- `print1()` - вывод очереди на экран.

####Программная реализация приоритетной очереди на основе бинарного поискового дерева
Приоритетная очередь на основе бинарного поискового дерева представлена классом `BSearchTree_Queue`, содержащим поле:
* `BSearchTree<KeyT>* search_tree` - указатель на дерево.
* `qsize` - размер очереди.

Класс содержит следующие методы:
- `SetQsize(int s)` - установить размер.
- `GetQsize(void)` - получить размер.
- `Pop()` - изьятие из начала(с мин меткой).
- `Top()` - изьятие  без удаления.
- `Insert(Node<KeyT>* node)` - вставка node.
- `IsEmpty()` - проверка на пустоту.
- `print1()` - вывод со списком ребер.
- `print2()` - вывод (обход в ширину).

####Программная реализация приоритетной очереди на основе упорядоченной таблицы
Приоритетная очередь на основе упорядоченной таблицы представлена классом `SortTable_Queue`, содержащим поля:
* `SortTable<KeyT>* table` - указатель на таблицу.
* `int qsize` - размер.

Класс содержит следующие методы:
- `SetQsize(int s)` - установить размер.
- `GetQsize(void)` - получить размер.
- `Pop()` - извлечение элемента.
- `Top()` - получение ребра.
- `Insert(Node<KeyT>* n)` - вставка node.
- `IsEmpty()` - проверка на пустоту.
- `print1()` - вывод со списком ребер.

####Программная реализация разделенных множеств
Разделенные множества представлены классом `Disjoint_set`, содержащим следующие поля:
* `int *p` - указатель на родителя для узла x.
* `int *h` - ранг-высота поддерева, корнем которого является узел x.
* `int maxsize` - макс кол элементов в множестве(мощность).

Класс содержит следующие методы:
- `CreateSingleton(const int x)` - создание синглтона.
- `Union(int x, int y)` - обьединение множеств.
- `FindSubset(int x)` - имя множества, которому принадлежит x.
- `Errors(int x)` - exceptions.
- `GetMaxsize()` - получить размер.
- `Print()` - печать.

####Программная реализация графа

Граф представлен классом `Graph`, содержащим следующие поля:
* `int gsize` - количество вершин графа.
* `KeyT** edges` - множество ребер.

Класс содержит следующие методы:
- `operator =(const Graph<KeyT> &g)` - оператор `=`.
- `Print()` - вывод графа.

##Заключение
В ходе лабораторной работы:
* Были реализованы структуры данных:
 - "Графы"
 - "Разделенные множества"
 - "d-куча"
 - "Бинарное поисковое дерево"
 - "Таблица"
 - "Просматриваемая таблица"
 - "Упорядоченная таблица"
 - "Приоритетная очередь на основе d-кучи"
 - "Приоритетная очередь на основе бинарного поискового дерева"
 - "Приоритетная очередь на основе упорядоченой таблицы"
* Написано тестирующее приложение, которое покрывает все методы, используемые в указанных классах. Все тесты успешно пройдены. 
* Написаны консольные приложения:
 - Пирамидальная сортировка.
 - алгоритм Дейкстры для поиска кратчайших путей от нулевой стартовой вершины связного неориентированного взвешенного графа без петель.
 - алгоритм Краскала для построения минимального остовного дерева неориентированного взвешенного графа без петель, реализованного на основе приоритетных очередях на базе d-кучи, бинарного поискового дерева и упорядоченной таблицы.

##Литература
1. Кормен Т., Лейзерсон Ч., Риверст Р., Штайн К. Алгоритмы. Построение и анализ. - М.: Издательский дом "Вильямс". - 2005. - 1290с.
2. Алексеев В.Е., Таланов В.А. Графы. Модели вычислений. Структуры данных: Учебник. – Нижний Новгород: Изд-во ННГУ, 2005. 307 с.